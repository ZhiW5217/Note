## python 数据类型
```
int 整形
float 浮点数
bool 布尔值
complex 复数
```

## False 对应的值
```
False: 0, 空值(空列表,空字典,空字符串,空元组),None    
```

## 可变类型和不可变类型
```
不可变类型：
    数字,字符串,元组
可变类型：
    列表,字典

    可变不可变指的是内存中的内容(value)是否可变,对一个不可变类型的变量进行重新赋值
    实际上是重新创建一个不可变类型的对象,并将原来的变量重新执行新的对象
```

## 什么值可以作为字典的key
```
 不可变类型可以作为字典的key：
    int,float,str,bool.tuple
```

## 函数

- 什么是函数
	- 广义上指为了达到某种目的而采用的某种手段,狭义指有一系列代码程序组成的代码块
- 函数的特性
	- 1.带有名字的代码段
	- 2.函数是代码重用的基础手段和重要手段
	
```python
	def func():
		pass
```

## 函数参数

- 参数分为形式参数和实际参数
	- 形参: 在编写函数是预定义的参数
	- 实参: 在调用函数时传递的参数

- 参数又分为位置参数,默认参数,命名关键字参数,可变参数
	
	- 位置参数

	```python
		# 定义函数
		def func(arg1,agr2,arg3):
			pass
		
		# 传递参数的两种方法让 arg1=3 arg2=2 arg3=1
		func(3,2,1)  

		func(arg3=1, arg1=3, arg1=3)  # 
	```
	
	- 默认参数
	```python
		# 可以为参数是定默认值,如果调用是传递该参数,则使用传递的参数,如果没有传递该参数,则使用设定的默认值
		# 定义函数
		def func(arg=None):
			return arg
			
		# 调用函数
		print(func())
		>>> None
		
		print(func(2))
		>>> 2
	```
	
	- 命名关键字参数 *
	```python
		# 命名关键字参数为显式命名传参 以`*`为标识
		# `*`后面的参数必须为显示命名传参
		
		# 定义函数
		def func(arg1,*,arg2,arg3):
			print(arg1, arg2, arg3)
			
		# 错误传参方式
		func(1, 2, 3)
		
		# 正确传参方式
		func(arg1=1, arg2=2, arg3=3)

		# 或者
		func(1, arg2=2, arg3=3)
	```
	- 可变参数 *args, **kwargs
		- !!! 注意可变参数和命名关键字参数不能同时出现
	```python
		# *args 可以接受0-N个参数,args的类型为tuple
		
		# 定义函数
		def func(*args):
			print(args)
			
		# 调用
		func(1)
		>>> (1,)
		
		func(1, 2, 3)
		>>> (1, 2, 3)
		
		def func1(a, *args):
			print(f"a={a}")
			print(f"args={args}")
		
		func1(1, 2, 3)
		>>> a=1
			args=(2, 3)
		
		# **kwargs 可以接受类似 `a=1` 的参数,kwargs的类型为dict
		
		# 定义函数
		def func(**kwargs):
			print(kwargs)
		
		# 调用
		func(a=1, b=2, c=3)
		>>> {'a': 1, 'b': 2, 'c': 3}
		
		# 总结
		def func(m, n, *args, **kwargs):
			print(f"m={m}")
			print(f"n={n}")
			print(f"args={args}")
			print(f"kwargs={kwargs}")
	
		func(1, 2, 3, 4, 5, a=6, b=7, c=8)
		>>> m=1
			n=2
			args=(3, 4, 5)
			kwargs={'a': 6, 'b': 7, 'c': 8}
	```
	
## 类(class)
- 什么是类
	- 类是拥有相同属性和相同功能的对象的集合(抽象)
	- 对象就是类的实例(具体)
```python
	class <类名>(父类):
		构造: 为对象开票空间
		类变量: 所有对象公用
		初始化: 成员方法
		类方法: 使用@classmethod 装饰,默认有一个cls参数,和类变量配合完成类的功能,可以被类和对象调用
		静态方法: 使用@staticmethod 进行装饰,只能出现在类的内部,类的静态方法可以没有参数,可以可以被类和对象调用
		成员方法/对象方法/普通方法: 默认有一个self参数,且只能被对象调用
		封装的成员属性: 增强成员变量使用的安全性,方便外部使用
		析构方法: 对象消失前的准备工作,会自动调用, 一般情况下省略
```
- 访问控制
	- 完全公开:标识符不以_开始
    - 保护(单下划线前缀):_标识符
    - 私有(双下划线前缀):__标识符

## 进程 线程和协程
- 进程: 
 	- 保存在硬盘上的程序运行以后,会在内存空间里形成一个独立的内存体,这个内存体有自己独立的地址空间,有自己的堆,上级挂靠单位是操作系统。
 	- 操作系统会以进程为单位,分配系统资源,进程是资源分配的最小单位
- 线程
	- 有时候会被称为轻量级进程
	- 是操作系统调度执行的最小单位
- 进程和线程的区别
	- 调度: 线程作为调度和分配的基本单位,进程作为拥有资源的基本单位
	- 并发性: 不仅进程之间可以并发执行,同一个进程的多个线程之间也可以并发执行
	- 拥有资源: 
			进程是拥有资源的一个独立单位,线程不拥有系统资源,但可以访隶属于进程的资源
			进程所维护的是程序所包含的资源
			线程所维护的是运行相关的资源
	- 系统开销:
			在创建或撤销进程是,由于系统都要为止分配和回收系统资源,导致系统的开销明显大于
			或撤销线程时的开销,但是进程有独立的地址空间,一个进程崩溃以后,在保护模式小
			不会对其他进程产生影响,而线程只是一个进程中不同执行路径,线程有自己的堆栈和
			局部变量,但线程之间没有单独的地址空间,一个进程死掉就等于这个进程下的所有线程
			死掉,所以多间的程序比多线程的程序健壮,但在进程切换是,耗费资源较大,效率要查一些。
- 进程和线程之间的联系
	- 一个线程只能属于一个进程,而一个进程可以有多个线程,但至少有一个线程
	- 资源分配给进程,同意进程的所有线程共享该进程的所有资源
	- 处理机分给线程,即真正在处理机上运行的是线程
	- 线程在执行过程中,需要协作同步。不同进程的线程间要用到消息通信的办法实现同步

- 协程
	- 协程是比线程更加轻量级的存在,协程不是被操作系统内核所管理,而完全是有程序所控制,这样的好处就是性能得到了提升,也不会像线程切换那样消耗资源
	- 协程在子程序内部是可以中断的,然后转而执行别的子程序,在适当的时候在回来接着执行
- 协程的优势
	- 协程有极高的执行效率:因为子程序切换不是线程切换,而是有程序自身控制,因此没有线程切换的开销,和多线程比,线程的数量越多,协程的性能优势就越明显
	- 不需要多线程的锁机制:因为只有一个线程,也不存在同时写变量冲突,在协程中控制共享资源不加锁,只需要判断状态记好了,所以执行效率比多线程高很多。
